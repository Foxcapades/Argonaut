= Argonaut Topics
:toc:

== Commands

[#singular-command]
=== Singular

A singular command, referred to in this document as just a command, defines an
executable that has no subcommands and may take any number of flags and/or
positional arguments.  Commands are buildable using the function
`cli.Command()`.  Some examples of singular commands are `cat`, `cut`, `sed`,
and `tar`.

As an example of command construction, the following is one way the CLI API for
the command `cat` could be built using Argonaut.  `cat` has a slightly
complicated API due to flags being shortcuts for other flag combinations.

[source, go]
----
type Config struct {
    NumberNonBlank bool
    NumberLines bool
    SqueezeBlank bool
    ShowTabs bool
    ShowEnds bool
    ShowNonPrinting bool
}

func main() {
    var config Config

    cli.Command().
        WithDescription("Concatenate FILE(s) to standard output.").
        WithFlag(cli.ComboFlag('A', "show-all").
            WithDescription("equivalent to -vET").
            WithCallback(func(_ argo.Flag) {
                config.ShowNonPrinting = true
                config.ShowEnds = true
                config.ShowTabs = true
            })).
        WithFlag(cli.ComboFlag('b', "number-nonblank").
            WithDescription("number nonempty output lines, overrides -n").
            WithBinding(&config.NumberNonBlank, false)).
        WithFlag(cli.ShortFlag('e').
            WithDescription("equivalent to -vE").
            WithCallback(func(_ argo.Flag) {
                config.ShowNonPrinting = true
                config.ShowEnds = true
            })).
        WithFlag(cli.ComboFlag('E', "show-ends").
            WithDescription("display $ at end of each line").
            WithBinding(&config.ShowEnds, false)).
        WithFlag(cli.ComboFlag('n', "number").
            WithDescription("number all output lines").
            WithBinding(&config.NumberLines, false)).
        WithFlag(cli.ComboFlag('s', "squeeze-blank").
            WithDescription("suppress repeated empty output lines").
            WithBinding(&config.SqueezeBlank, false)).
        WithFlag(cli.ShortFlag('t').
            WithDescription("equivalent to -vT").
            WithCallback(func(_ argo.Flag) {
                config.ShowNonPrinting = true
                config.ShowTabs = true
            })).
        WithFlag(cli.ComboFlag('T', "show-tabs").
            WithDescription("display TAB characters as ^I").
            WithBinding(&config.ShowTabs, false)).
        WithFlag(cli.ComboFlag('v', "show-nonprinting").
            WithDescription("use ^ and M- notation, except for LFD and TAB").
            WithBinding(&config.ShowNonPrinting, false)).
        WithFlag(cli.LongFlag("version").
            WithDescription("output version information and exit").
            WithCallback(func(_ argo.Flag) {
                fmt.Println("<version information>")
                os.Exit(0)
            })).
        WithUnmappedLabel("FILE...").
        MustParse(os.Args)
}
----

=== Command Trees

Command trees represent a tree of subcommands consisting of branches and leaves
which allow the creation of multiple "separate" commands under a single root
executable.  Command trees are buildable using the `cli.Tree()` function.

[source, go]
----
cli.Tree().
    WithBranch(cli.Branch("foo").
        WithLeaf(cli.Leaf("bar"))).
    WithBranch(cli.Branch("fizz").
        WithLeaf(cli.Leaf("buzz"))).
    MustParse(os.Args)
----

Examples of command tree style applications include `go`, `docker`, `kubectl`,
`vault`, and many more.

For a call to a command tree to be valid, the caller must reach a leaf node
under the tree or one of its branches, if a leaf node is not reached and the
caller stops on a branch or on the root tree node, a customizable action is
executed.  The default action is to print the help text for the command node
that was reached.

[source, console]
----
$ my-app
Usage:
  my-app [options] <command>

Flags
  -h | --help
      Prints this help text.

Commands
  fizz
  foo
----
[source, console]
----
$ my-app foo
Usage:
  my-app foo [options] <command>

Flags
  -h | --help
      Prints this help text.

Commands
  bar
----

The following is an example of setting up a very simple command tree which has
2 branches, and one leaf under each branch.  On execution, the example will
print a message based on which command path is chosen.

.Tree Structure
[source]
----
app:
  |- foo
  |    |- bar
  |- fizz
       |- buzz
----

.Argonaut Code
[source, go]
----
cli.Tree().
    WithCallback(func(tree argo.CommandTree) { fmt.Print("hello") }).
    WithBranch(cli.Branch("foo").
        WithCallback(func(branch argo.CommandBranch) { fmt.Print(" to") }).
        WithLeaf(cli.Leaf("bar").
            WithCallback(func(leaf argo.CommandLeaf) { fmt.Println(" you") }))).
    WithBranch(cli.Branch("fizz").
        WithCallback(func(branch argo.CommandBranch) { fmt.Print(" you") }).
        WithLeaf(cli.Leaf("buzz").
            WithCallback(func(leaf argo.CommandLeaf) { fmt.Println(" goober") }).
    MustParse(os.Args)
----

Because command tree node callbacks are called in the order they appear in the
CLI call, the above example will print either "hello to you", or "hello you
goober" depending on which command path is called.

== Deserialization

=== Variable Bindings

An argument may be bound to a specified variable to be automatically
deserialized into that variable.

[source, go]
----
var foo time.Duration

cli.Argument().WithBinding(&foo)
----

The type of the bound variable will be automatically detected and will be
deserialized from the raw input using either the built-in "magic" unmarshaler,
or a provided custom input unmarshaler.

The variable binding of an argument controls the type of the argument and
defines what default values, providers, or validators may be used with the
argument.  Due to limitations present in Go's current generics implementation
the function argument type must be 'any'.

==== Binding Types

===== Built-in

By default, Argonaut can handle deserializing most primitive types, as well as
`time.Duration` and `time.Time`.  The only "primitive" types that Argonaut does
not currently handle out of the box are `complex64` and `complex128`.

[source, go]
----
type Config struct {
    Verbose   bool
    InputFile string
    MaxLines  int
    Timeout time.Duration
}

var config Config

cli.Command().
    WithFlag(cli.ShortFlag('v').WithBinding(&config.Verbose, false)).
    WithFlag(cli.ShortFlag('m').WithBinding(&config.MaxLines, true)).
    WithFlag(cli.ShortFlag('t').WithBinding(&config.Timeout, true)).
    WithArgument(cli.Argument().WithBinding(&config.InputFile))
----

===== Custom

Custom, arbitrary types may also be handled by Argonaut, provided the implement
the `argo.Unmarshaler` interface which will be passed the raw input from the CLI
and will be expected to handle the type's deserialization internally.

[source,go]
----
type Row [4]string

func (r *Row) Unmarshal(raw string) error {
    tmp := strings.SplitN(raw, ",", 4)
    copy(r[:], tmp)
    return nil
}

func main() {
    var row Row
    cli.Command().
        WithArgument(cli.Argument().WithBinding(&row))
}
----

=== Consumers

While an argument may be bound to a variable pointer to deserialize a value, it
may instead be bound to a consumer function which may optionally return an
error.

.Without Error
[source, go]
----
cli.Argument().
    WithBinding(func(t time.Time) {
        fmt.Println(t)
    })
----

.With Error
[source, go]
----
cli.Argument().
    WithBinding(func(count int) error {
        if (count < 1) {
            return errors.New("count must be 1 or greater")
        }
        // do something with count
        return nil
    })
----

=== Defaults

Arguments may be provided a default value which will be set to the binding
variable when the argument is not used in the CLI call.

An argument default may be a static value, or a value provider function.

==== Values

The most common use case for default values is to provide some static value that
the command can assume when no value is specified.

[source, go]
----
cli.Argument().WithBinding(&foo).WithDefault(35)
----

A static default value must be one of 2 things: A string value that may be
deserialized into the type expected by the binding, or a raw value of the same
type as the binding.

The following example would fail at command build time due to the mismatched
types between binding and default:

[source, go]
----
var foo int

cli.Argument().WithBinding(&foo).WithDefault(true)
----

==== Providers

In addition to raw values, an argument's default value may come from a default
provider function.  Argument default provider functions come in 2 flavors, a
single value returning function that returns a value of the same type as the
binding value, or a double value returning function that returns an error in
addition to a value of the expected binding type.

.Single Return
[source, go]
----
cli.Argument().WithBinding(&foo).WithDefault(func() int { return 3 })
----

.Double Return
[source, go]
----
cli.Argument().WithBinding(&foo).WithDefault(func() (int, error) { return 3, nil } )
----

== Validation

There are multiple levels of validation performed by Argonaut:

. Builder-build-time sanity checking
. Pre-parse argument validation
. Post-parse argument validation
. Flag and/or argument requirements

=== Builder Sanity Checking

This check is performed when an Argonaut component builder's `Build()` function
is called.  At that time the configuration of the composed command structure is
validated to ensure that there are no problems that will be encountered during
the use of or deserialization from an actual CLI call.

Build-time sanity checking verifies that there are no flag name collisions,
command branch or leaf name collisions, argument binding issues, argument
default and binding mismatches, etc...

=== Pre-Parse Argument Validation

Argument inputs may be optionally validated by a provided function before they
are parsed.  This allows for cheap input checks for obviously incorrect inputs.

Argument pre-parse validators are functions that take a single string argument
and return an error on invalid input.

[source, go]
----
cli.Argument().WithValidator(func(raw string) error {
    if len(raw) > 10 {
        return errors.New("input cannot be longer more than 10 characters in length")
    }
})
----

=== Post-Parse Argument Validation

Argument inputs may be optionally validated by a provided function after they
are parsed.  This allows for validation of inputs to be performed as part of the
CLI parsing process.

Argument post-parse validators are functions that take 2 arguments, the first is
of the same type as the argument binding, the second is a string that will be
the raw value passed on the CLI.  This function should return an error on failed
validation.

[source, go]
----
cli.Argument().WithValidator(func(parsed int, raw string) error {
    if parsed > 10 {
        return errors.New("input cannot be greater than 10")
    }
})
----

=== Flag and Argument Requirements

Flags and/or arguments may be marked as required.  When CLI parsing is complete,
Argonaut will return an error if any required flags or arguments were not
present in the CLI call.

[source, go]
----
// Required Flag
cli.Flag().Require()
// Required Argument
cli.Argument().Require()
----

== Help Text Generation

Argonaut includes help text rendering with an overridable default implementation
of an included `HelpRenderer` interface.

Using the example construction of the `cat` CLI API from the
<<#singular-command, Singular Command>> section, Argonaut generates the
following text.

[source, console]
----
$ cat2 -h
Usage:
  cat2 [options] [FILE...]

    Concatenate FILE(s) to standard output.

General Flags
  -A | --show-all
      equivalent to -vET
  -b | --number-nonblank
      number nonempty output lines, overrides -n
  -e
      equivalent to -vE
  -E | --show-ends
      display $ at end of each line
  -n | --number
      number all output lines
  -s | --squeeze-blank
      suppress repeated empty output lines
  -t
      equivalent to -vT
  -T | --show-tabs
      display TAB characters as ^I
  -v | --show-nonprinting
      use ^ and M- notation, except for LFD and TAB
  --version
      output version information and exit

Help Flags
  -h | --help
      Prints this help text.
----
